package org.example;

import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;

public class Examen {

    public static void main(String[] args) {

//        Stack<Integer> pila = new Stack<>(); //pila
//        pila.pop(); //insertar
//        pila.push(); //sacar
//        pila.peek(); //devuelve el ultimo
//
//        Queue<Integer> cola = new ArrayBlockingQueue<>(3);//capacidad maxima
//        cola.offer(); //insertar
//        cola.poll(); //eliminar
//        cola.element(); //obtiene primer elemento lanza excepción si la cola esta vacia
//        cola.peek(); //obtiene el primer elementto sin elminar
//
//        Queue<String> cola2 = new LinkedList<>();
//
//        cola.offer(); //insertar first last
//        cola.poll(); //eliminar first last
//        cola.element(); //obtiene primer elemento lanza excepción si la cola esta vacia first last
//        cola.peek(); //obtiene el primer elementto sin elminar first last
//        //.remove first last
//
//        Set<String> conjunto = new HashSet<>() ;//desordenada
//        Set<String> conjunto_orden = new LinkedHashSet<>() ;//ordenada
//        Set<String> conjunto_arbol = new TreeSet<>() ;// estructura de arbol
//
//        HashMap<String, Integer> edades = new HashMap<>();
//        edades.put()//añadir
//        edades.get() //obtener
//        edades.remove();
//        edades.containsKey();
//        edades.containsValue();
//        edades.keySet(); //lista de claves
//        edades.values(); //lista de valores
//
//        Iterator<String> it = ejemplo.iterator(); //permite recorrer una colección de elementos secuencialmente sin exponer su estructura interna.
//        it.hasNext(); //dice si hay siguiente
//        it.next() //muestra el siguiente
//        it.remove(); //elimina el elemento devueto
//
//
//        ListIterator<String> si = ejemplo.listIterator();  //ambas direcciones (hacia adelante y hacia atrás), además de modificar la lista de forma segura durante la iteración con algunos métodos añadidos.
//
//





    }

}
